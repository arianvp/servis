\documentclass[12pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{minted}
\usepackage[left=2cm,right=2cm,top=2cm,bottom=2cm]{geometry}
\author{Arian van Putten \\ a.vanputten@uu.nl}
\title{Servis: A dependently typed DSL for web APIs}
\begin{document}
\maketitle
\begin{abstract}
In this paper, we describe a DSL for web APIs named Servis. Servis is heavily inspired by Servant, a haskell type-level DSL for web APIs,  but tries to solve identified shortcomings by using a dependently typed language called Idris. Servis uses the universe pattern to deduce types from an API description such that we can verify at compile time that the implementation of the API matches the description.

Furthermore, we take a look at if dependent types can bring more to the table in terms of expressiveness of API descriptions than the original Servant DSL\@. Specifically, we introduce $\pi$-types to describe interdependencies within an API description.

  TODO: rewrite abstract \emph{after} I finish the paper :-)

\end{abstract}

\section{Introduction}
Servant is an extensible type-level DSL for Haskell, that tries to make web APIs \emph{first-class}~\cite{servant}. A web API should be a thing that can be named, passed to, or returned by functions. Just like any other term in a language.

It does this by describing the DSL at the type-level. And then uses \emph{type families} (type-level functions) to be able to perform computations on the API specifications.  Using these type families, we are able to write different \emph{interpretations} of an API\@.  Example of interpretations are: generating documentation from a specification, generating types of a server implementation, or even generating a client that can interfact with the API\@.

In this paper, I will describe a port of Servant in Idris, and explore what kind of benefits this brings us.

\subsection{An introduction to Servant}
I will now give a very short overview of the internals of Servant. We will start by describing the type-level DSL of servant. 

\begin{listing}[H]
\begin{minted}{haskell}
data api1 :<|> api2
infixr 8 :<|>

data (item :: k) :> api
infixr 9 :>

data ReqBody (ctypes :: [*] (t :: *)
data Capture (symbol :: Symbol) (t :: *)

data Get (ctypes :: [*]) (t :: *)
data Post (ctypes :: [*]) (t :: *)
data JSON
\end{minted}
\caption{The Servant DSL}
\label{lab:servant}
\end{listing}

TODO give a short overview of servant



Servant has a few limitations which we will describe in Section~\ref{sec:limitations}. 


\subsection{Why idris}
Idris is a language that in syntax is rather similar to Haskell, but has a more powerful type system. Idris is a dependently-typed language. This means that types are fist-class citizens. We can pass types to functions, let functions create new types, and let types depend on other value-level terms.

Though haskell has type-level functions (called type-families), it does not allow these functions to dpend on term-level values. There is a distinct boundary between type-level and term-level, whilst the two are merged in Idris. This makes doing computations with types a lot more natural (no special constructs are needed, just write functions), but also lets us do some more powerful stuff like letting types actually depend on runtime user input.

Dependent Haskell is currently in the making, and probably planned for around GHC version 8.6~\cite{neeeded}. In the future, it would probably be very feasible to port this library back to Haskell and bring all the benefits along with it.

\subsection{Contributions}
In this paper, I make the following contributions:

TODO reword
\begin{itemize}
  \item I point out several problems an limitations of the original Servant DSL
  \item I show a port of servant to Idris, a dependently-typed language
  \item I show how new techniques from Idris can help mitigate some of the problems that Servant has.
\end{itemize}

\section{Limitations of Servant}\label{sec:issues}
\subsection{Term and type-level are not unified in Haskell}
As explained in the introduction, the Servant DSL lives in the type-level. In haskell, types and terms are separated. One can lift terms into the type-level using GHC extensions like \texttt{XDataKinds}, but that only gets us so far.  On the term level, Haskell has many great libraries and data structures that can be used. For example, all kinds of string manipulations. It would be useful to be able to use these functions to manipulate APIs, making them truly first-class. Now they are only first-class in the type level.

For example, a useful function would be \mintinline{haskell}{path "/users/friends/etc" = "users" :> "friends" :> "etc"} to reduce noise in the DSL\@. But this is currently impossible to write because Strings in the type level are of kind \mintinline{haskell}{Symbol} and not \mintinline{haskell}{String} so all our favorite string manipulation functions like \mintinline{haskell}{splitOn "/"} will not work. This would mean that we would have to re-implement all kinds of utility functions on the type-level.

\subsection{A kind of APIs}
As mentioned in Section~\ref{sec:servant_intro}, a delibirate choice has been made to let the Servant DSL live in the open kind \mintinline{haskell}{*}. Though this makes the DSL extensible, it also makes the DSL fragile and prone to error.

To give a real-world example, here is a snippet from a user on the Haskell Subreddit that could not get his API to work:

\begin{listing}[H]
\begin{minted}{haskell}
type SoundcloudTrackAPI = "tracks" :> 
  (    QueryParam "client_id" T.Text 
    :> QueryParams "genres" T.Text
    -> Get [JSON] [ST.Track] 
  :<|> QueryParam "client_id" T.Text
    :> Capture "id" Int
    :> Get [JSON] ST.Track
  )
\end{minted}
\caption{A malformed API}
\label{code:problem}
\end{listing}

The problem is hard to spot, but the user typed wrote \mintinline{haskell}{->} instead of \mintinline{haskell}{:>}.  This code compiles fine though. Because the Servant DSL lives in kind \mintinline{haskell}{*}, \mintinline{haskell}{:>} is   of kind \mintinline{haskell}{* -> * -> *}. Which is the same kind as the kind of \mintinline{haskell}{->}.

Only when one would try to interpret the DSL, like in Listing~\ref{code:interpret}, one would get a type error because no type family pattern matches on \mintinline{haskell}{->}.

\begin{listing}
\begin{minted}{haskell}
searchTracksByGenre :: Maybe T.Text 
                    -> [T.Text]
                    ->  Manager
                    -> BaseUrl
                    -> ClientM [ST.Track]
getTrack            :: Maybe T.Text
                    -> Int
                    -> Manager
                    -> BaseUrl
                    -> ClientM ST.Track
(searchTracksByGenre :<|> getTrack) = client soundcloudAPI 
\end{minted}
  \caption{An interpretation of the API (Listing ~\ref{code:problem})}
  \label{code:interpret}.
\end{listing}

Preferably, one would want to define a new open kind \mintinline{haskell}{API} such that \mintinline{haskell}{(:>) :: API -> API -> API}, but this is not possible in Haskell (or Idris). Instead, one could define a closed kind (using \textt{XDataKinds}), in which we define the entire Servant DSL. This would mean we would lose extensibility of the DSL, but we gain kind-safety.

Also, as described in Section~\ref{sec:servant_intro}, the Servant DSL is split up in several semantic portions.  For example, \mintinline{haskell}{:>} should take an \mintinline{haskell}{item} on the left-hand side, which describes either a constraint like \mintinline{haskell}{ReqBody} or a path-piece, whilst the right-hand side should be an \mintinline{haskell}{api}. These semantic portions are implict and not checked though. So we can create totally non-sensical API types like \mintinline{haskell}{type Nonsense = (Int :>Int) :<|> ("hey ":> Int)} that have no interpretation at all.

Instead of having these implicit semantic rules about what kind of arguments an operator can take in the Servant DSL, we could define a distinct closed kind for each semantic portion. Such that the type of \mintinline{haskell}{:>} changes to the following: \mintinline{haskell}{(:>) :: Item -> API -> API}.

Another implict rule is, that a chain of \mintinline{haskell}{:>} should always end in a \mintinline{haskell}{Get} or a \mintinline{haskell}{Post}. So this should be invalid: \mintinline{haskell}{type API = "a" :> ReqBody [JSON] User}.  This can also not be checked if we do not add more fine-grained kinds to the DSL.

\subsection{Explicit status codes}
An API that describes how stuff goes right is good, and API that describes how stuff goes wrong is great. But currently, Servant has no way to indicate in the API description what kind of status codes an endpoint can return. Thus this also does not show up in the generated documentation.

It would be nice to add a list of possible status codes that an endpoint can returns, and then also be able to check whether a server implementation actually only returns one of the specified status codes if something goes wrong (or right).

\subsection{Overlapping routes}
Another problem with Servant is that there is no protection for overlapping routes. If two routes could resolve to the same path, Servant makes a left-biased choice~\cite{needed}.
It would be nice if we could verify at compile time that no routes in an API specification can overlap.

\begin{listing}
\begin{minted}{haskell}
  type API  = "users" :> Capture "args" String :> Get [JSON] User
         :<|> "users" :> "favorites" :> GET [JSON] User
\end{minted}{haskell}
\caption{An example of overlapping routes. The capture will be chosen if args equals "favorites"}
\end{listing}



\section{Servis}
In this section, I present a DSL in Idris named Servis. It tries to address each issue listed in Section~\ref{sec:issues}. Firstly, we will define the DSL in which we can write API specifications. Then, we will look at how to write an interpreter of this DSL that generates documentation. Then, we will look at how we would implement HTTP webserver handlers that adhere to specification defined by the API DSL\@. Next, we'll look at solving the overlapping routes problem by writing proofs in Idris.
Finally, we will extend the DSL to add \emph{pi-types}, allowing us to describe dependencies in our API\@.  For example, one might want to describe  the size of a list of users in the API, but let the size depend on a query parameter \emph{limit} that limits the response size.  It would then force the implementor of the API to only return values smaller or equal to limit in size.

\subsection{The Universe pattern}
The Servis DSL makes use of the Universe pattern to map an API description to types of handlers.
 A universe is a type \mintinline{idris}{U : Type} which contains names for types and a type family \mintinline{idris}{el : U -> Type} that assigns to every name \mintinline{idris}{a : U} the type of its elements \mintinline{idris}{el a : Type} \cite{generic}\@.

 In idris, we could define this as the following interface:
 \begin{listing}
 \begin{minted}{idris}
interface Universe (u : Type) where
  el : u -> Type
 \end{minted}{idris}
   \caption{Universe interface in Idris}
 \end{listing}

 In our case, we have a datatype \mintinline{idris}{API : Type}, which describes our API, and \mintinline{idris}{el} maps values to handler types. A Short example:
 \begin{minted}{idris}

-- we define a value of API
api : API
api = Const "users" :> Capture Int "userId" :> Outputs (Get USER)

getUser : Int -> IO User
getUser = ?someDatabaseMagic

--  el api evaluates to  Int -> IO User
handler : el api
handler = getUser
 \end{minted}
\subsection{The DSL}
So what does this type \mintinline{idris}{API} look like?
\subsubsection{Handler}
Before we will look at routes, lets think of what an endpoint should look like.
We should be able to handle the HTTP verbs. We will only implement \mintinline{idris}{GET} and \mintinline{idris}{POST}, because the others are very similar.
For a \mintinline{idris}{GET}, we should be able to specify a return type of the handler,  and for a \mintinline{idris}{POST}, we should be able to
specify a request body type, and a return type.


A first try at describing this as a datatype for our universe  could look something like this:
\begin{listing}
  \begin{minted}{idris}
data Handler : Type where
  GET : (responseType : Type) -> Handler req res
  POST : (requestType : Type) -> (responseType : Type) -> Handler req res

Universe Handler where
  -- a GET handler just returns something of type responseType
  el (GET responseType) = IO responseType
  -- a POST handler takes the requestBody as argument, and returns a response
  el (POST requestType responseType) = requestType -> IO responseType

  \end{minted}
\end{listing}

We could then define a handler for \mintinline{idris}{GET}ting users as follows:
\begin{minted}{idris}
record User where
  constructor MkUser
  name : String
  email : String

userHandler : Handler
userHandler = GET User
\end{minted}

However, once we start implementating an actual server in Section~\ref{sec:server}, we will discover that this definition is not ideal. What if we want to write some
function that does something different based on the \mintinline{idris}{responseType} of a \mintinline{idris}{GET}?
For example, based on value of \mintinline{idris}{responseType}, we need to decide how to encode the response body to JSON. Lets imagine a hypothetical function \mintinline{idris}{selectEncoder} that tries to implement this behaviour:

\begin{minted}{idris}
selectEncoder : Type -> Encoder
selectEncoder User = ?jsonEncoderForAUser

userEncoder : Encoder
userEncoder = selectEncoder User
\end{minted}{idris}

Sadly enough, this will give us a compiler error. The problem is that in Idirs, we cannot pattern match on values of \mintinline{idris}{Type}. 
However, this exact problem can be solved with universes! We can define a data type \mintinline{idris}{ResponseUniverse : Type} which names
the \mintinline{idris}{User} type. We can then pattern-match on \mintinline{idris}{ResponseUniverse} instead of \mintinline{idris}{Type}!
And whenever we need the \mintinline{idris}{User} type, we can just call \mintinline{idris}{el USER : Type}.

\begin{minted}{idris}
data ResponseUniverse : Type where
  USER : ResponseUniverse

Universe ResponseUniverse where
  el USER = User

selectEncoder : ResponseUniverse -> Encoder
selectEncoder USER = ?jsonEncoderForAUser

userEncoder : Encoder
userEncoder : selectEncoder USER
\end{minted}

This leads us to the following definition of \mintinline{idris}{Handler}:

\begin{listing}
  \begin{minted}{idris}
data Handler : (req : Type)  -> (res : Type) -> Type where
  GET : (responseType : res) -> Handler req res
  POST : (requestType : req) -> (responseType : res) -> Handler req res

(Universe req, Universe res) => Universe (Handler req res) where
  el (GET responseType) = IO (el responseType)
  el (POST requestType responseType) =
    el requestType -> IO (el responseType)
  \end{minted}
  \caption{The new Handler definition}
\end{listing}

\subsubsection{Path and PathPart}
Of course we do not only get request information from the request body,
we also get information about a request by parsing it's request URL. This
is where \mintinline{idris}{Path}s and \mintinline{idris}{PathPart}s come into play. 
When we talk about path parts, we mean sections of an path template that convey parsable information.
For example, the following path template has three path parts: \texttt{/users/\string{user\_id\string}?search=\string{query\string}}. A constant piece
in the path \texttt{users}, a variable capture \texttt{user\_id} and a query param \texttt{search}. This
decomposition of a path template can be written down as a datatype. In this datatype we do not only
want to describe the names of the parts of these paths, but also their types. Hence, we will parameterize
over a universe similarly to how we defined \mintinline{idris}{Handler}.
\begin{minted}{idris}

||| PathPart is a part of a path.
||| @ capture the universe of captures
||| @ query   the universe of query params
data PathPart : (capture : Type) -> (query : Type) -> Type where
  ||| A constant piece of text
  ||| @ path the path part
  Const : (path : String) -> PathPart capture query
  ||| A capture of a variable name of a specific type
  ||| @ name  the name of the variable
  ||| @ type  the type of the variable
  Capture : (name : String) -> (type : capture) -> PathPart capture query
  ||| A query param of a variable name of a specific type
  ||| @ name  the name of the variable
  ||| @ type  the type of the variable
  QueryParam : (name : String) -> (type : query) -> PathPart capture query
\end{minted}

A \mintinline{idris}{Path} is simply a list if \mintinline{idris}{PathPart}s, which ends in a \mintinline{idris}{Handler}:
\begin{minted}{idris}
||| Describes a Path. A Path consists of path parts followed by a handler
data Path : (capture : Type) -> 
            (query : Type) ->
            (req : Type) ->
            (res : Type) -> Type where
  ||| Ends a path with a handler
  ||| @ handler the handler
  Outputs : (handler : Handler req res) -> Path capture query req res
  ||| Conses a pathpart to a path
  (:>) : PathPart capture query -> Path capture query req res -> Path capture query req res
infixr 5 :>
\end{minted}

The Path we just described can now be written as
\begin{minted}{idris}
   Const "users"
:> Capture "user_id" INT
:> QueryParam "search" STRING
:> Outputs (GET USER)
\end{minted}

The universe implementation is straightforward for paths, except for
that we do not wannt to have spurious arguments in case when we encounter
a \mintinline{idris}{Const}:
\begin{minted}{idris}
( Universe capture
, Universe query
) => Universe (PathPart capture query) where
  el (Const path) = ()
  el (Capture name type) = el type
  el (QueryParam name type) = el type


( Universe capture
, Universe query
, Universe req
, Universe resp
) => Universe (Path capture query req resp) where
  -- special case because we don't like () in our handler functions
  el (Const path :> right) =  el right
  el (pathPart :> right) = el pathPart -> el right
  el (Outputs handler) = el handler
\end{minted}

\subsubsection{The API Datatype}
Finally, we define an \mintinline{idris}{API} as an non-empty list of \mintinline{idris}{Path}s.

\begin{minted}{idris}
data API : (capture : Type) -> (query : Type) -> (req : Type) -> (res : Type) -> Type where
  OneOf : (paths : Vect (S n) (Path capture query req res)) -> API capture query req res
\end{minted}

The universe implementation of an API is the type of a list of handlers.
Every handler is of a different type though, so instead of using an ordinary list,
we use an heterogenous list, where each element \mintinline{idris}{x} in \mintinline{idris}{xs}
is of type \mintinline{idris}{el x}.
\begin{minted}
( Universe capture
, Universe query
, Universe req
, Universe res
) => Universe (API capture query req res) where
  el (OneOf xs) = HVect (map el xs)

\subsection{A simple interpreter: Documentation generation}
Here we will show a simple interpretation of the DSL, by generating some basic documentation.
It's basically a function \mintinline{idris}{docs : API -> String}. 
\subsection{An interpreter for an HTTP Server}\label{sec:server}
A more advanced example where we define two interpreters. One 'interpreter' that generates types from our DSL such that we can type-check our server handler implementations. (The universe pattern), and another interpreter that routes requests to these handler implementations.
\subsubsection{Checking explicit status codes}
Shows that we can enforce explicit status codes

\subsection{A proof of non-overlapping routes}
We will describe types for helping prove that routes in an API definition don't overlap.  We do this
by providing Decidable Equality proofs for all parts of our DSL.
\begin{minted}{idris}

||| A Proof that the GET dtor is injective over its requestType
injGET : (GET x = GET y) -> x = y
injGET Refl = Refl

||| A proof that the POST dtor is injective over its requestType
injPOSTReq : (POST requestType1 responseType1 = POST requestType2 responseType2) -> requestType1 = requestType2
injPOSTReq Refl = Refl

||| A Proof that the POST dtor is injective over its responseType
injPOSTResp : (POST requestType1 responseType1 = POST requestType2 responseType2) -> responseType1 = responseType2
injPOSTResp Refl = Refl

||| A Proof that a GET is not a POST
getNotPost : (GET responseType = POST requestType responseType1) -> Void
getNotPost Refl impossible

||| A proof that GET is congruent
cong_GET : (prf : responseType1 = responseType2) -> GET responseType1 = GET responseType2
cong_GET = cong

||| A proof POST is congruent
cong_POST : (prf2 : responseType1 = responseType2) -> (prf1 : requestType1 = requestType2) -> POST requestType1 responseType1 = POST requestType2 responseType2
cong_POST Refl Refl = Refl

(DecEq req, DecEq res) => DecEq (Handler req res) where
  decEq (GET responseType1) (GET responseType2) =
    (case decEq responseType1 responseType2 of
          (Yes prf) => Yes (cong prf)
          (No contra) => No ((\h => contra (injGET h))))
  decEq (POST requestType1 responseType1) (POST requestType2 responseType2) =
    (case decEq requestType1 requestType2 of
          (Yes prf1) => (case decEq responseType1 responseType2 of
                             (Yes prf2) => Yes (cong_POST prf2 prf1)
                             (No contra) => No (\h => contra (injPOSTResp h)))
          (No contra) => No (\h => contra (injPOSTReq h)))
  decEq (GET _) (POST _ _) = No getNotPost
  decEq (POST _ _) (GET _) = No (negEqSym getNotPost)
data DisjointPP : PathPart capture query -> PathPart capture query -> Type where
  ConstD : Not (str = str') -> DisjointPP (Const str) (Const str')

data DisjointPath : Path capture query req res -> Path capture query req res -> Type where
  OutputsD : Not (handler1 = handler2) -> DisjointPath (Outputs handler1) (Outputs handler2)
  PathBase : DisjointPP pp1 pp2 -> DisjointPath (pp1 :> p1) (pp2 :> p2)
  PathStep : DisjointPath p1 p2 -> DisjointPath (p :> p1) (p :> p2)


data DisjointAPI : List (Path capture query req res) -> Type where
  Base : DisjointAPI []
  Step : (x : Path capture query req res) -> All (DisjointPath x) xs -> DisjointAPI (x::xs)
\end{minted}
\subsection{Pi-types}
Adds dependent pairs to our DSL such that we can describe dependencies between query params, captures and return types.  Example:

\begin{minted}{haskell}
exampleOfDependentPath : Path EmptyU QueryU EmptyU RespU
exampleOfDependentPath =
  QueryParam "limit" NAT :*> \limit => Outputs (GET (BLIST limit USER))

getUsersLimit : (limit : Nat) -> IO (BoundedList limit User)
getUsersLimit limit = pure . take limit $ users

exampleOfDependentPathHandler : el Example.exampleOfDependentPath
exampleOfDependentPathHandler = getUsersLimit

\end{minted}
\subsection{New problems that pi-type create}
Here we will describe how pi-types adds problems. For example we cannot easily generate documentation anymore, prove that there are no overlapping routes, or prove that statuscodes are adhered to.

\section{Summary}
\section{Related work}
Talk about tel/serv. An inspiration for this project.
\section{Conclusions and future work}

\end{document}
