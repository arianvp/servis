\documentclass[12pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{minted}
\usepackage[left=2cm,right=2cm,top=2cm,bottom=2cm]{geometry}
\author{Arian van Putten \\ a.vanputten@uu.nl}
\title{Servis: A dependently typed DSL for web APIs}
\begin{document}
\maketitle
\begin{abstract}
In this paper, we describe a DSL for web APIs named Servis. Servis is heavily inspired by Servant, a haskell type-level DSL for web APIs,  but tries to solve identified shortcomings by using a dependently typed language called Idris. Servis uses the universe pattern to deduce types from an API description such that we can verify at compile time that the implementation of the API matches the description.

Furthermore, we take a look at if dependent types can bring more to the table in terms of expressiveness of API descriptions than the original Servant DSL\@. Specifically, we introduce $\pi$-types to describe interdependencies within an API description.

  TODO: rewrite abstract \emph{after} I finish the paper :-)

\end{abstract}

\section{Introduction}
Servant is an extensible type-level DSL for Haskell, that tries to make web APIs \emph{first-class}~\cite{servant}. A web API should be a thing that can be named, passed to, or returned by functions. Just like any other term in a language.

It does this by describing the DSL at the type-level. And then uses \emph{type families} (type-level functions) to be able to perform computations on the API specifications.  Using these type families, we are able to write different \emph{interpretations} of an API\@.  Example of interpretations are: generating documentation from a specification, generating types of a server implementation, or even generating a client that can interfact with the API\@.

In this paper, I will describe a port of Servant in Idris, and explore what kind of benefits this brings us.

\subsection{An introduction to Servant}
I will now give a very short overview of the internals of Servant. We will start by describing the type-level DSL of servant. 

\begin{listing}[H]
\begin{minted}{haskell}
data api1 :<|> api2
infixr 8 :<|>

data (item :: k) :> api
infixr 9 :>

data ReqBody (ctypes :: [*] (t :: *)
data Capture (symbol :: Symbol) (t :: *)

data Get (ctypes :: [*]) (t :: *)
data Post (ctypes :: [*]) (t :: *)
data JSON
\end{minted}
\caption{The Servant DSL}
\label{lab:servant}
\end{listing}

TODO give a short overview of servant



Servant has a few limitations which we will describe in Section~\ref{sec:limitations}. 


\subsection{Why idris}
Idris is a language that in syntax is rather similar to Haskell, but has a more powerful type system. Idris is a dependently-typed language. This means that types are fist-class citizens. We can pass types to functions, let functions create new types, and let types depend on other value-level terms.

Though haskell has type-level functions (called type-families), it does not allow these functions to dpend on term-level values. There is a distinct boundary between type-level and term-level, whilst the two are merged in Idris. This makes doing computations with types a lot more natural (no special constructs are needed, just write functions), but also lets us do some more powerful stuff like letting types actually depend on runtime user input.

Dependent Haskell is currently in the making, and probably planned for around GHC version 8.6~\cite{neeeded}. In the future, it would probably be very feasible to port this library back to Haskell and bring all the benefits along with it.

\subsection{Contributions}
In this paper, I make the following contributions:

TODO reword
\begin{itemize}
  \item I point out several problems an limitations of the original Servant DSL
  \item I show a port of servant to Idris, a dependently-typed language
  \item I show how new techniques from Idris can help mitigate some of the problems that Servant has.
\end{itemize}

\section{Limitations of Servant}\label{sec:issues}
\subsection{Term and type-level are not unified in Haskell}
As explained in the introduction, the Servant DSL lives in the type-level. In haskell, types and terms are separated. One can lift terms into the type-level using GHC extensions like \texttt{XDataKinds}, but that only gets us so far.  On the term level, Haskell has many great libraries and data structures that can be used. For example, all kinds of string manipulations. It would be useful to be able to use these functions to manipulate APIs, making them truly first-class. Now they are only first-class in the type level.

For example, a useful function would be \mintinline{haskell}{path "/users/friends/etc" = "users" :> "friends" :> "etc"} to reduce noise in the DSL\@. But this is currently impossible to write because Strings in the type level are of kind \mintinline{haskell}{Symbol} and not \mintinline{haskell}{String} so all our favorite string manipulation functions like \mintinline{haskell}{splitOn "/"} will not work. This would mean that we would have to re-implement all kinds of utility functions on the type-level.

\subsection{A kind of APIs}
As mentioned in Section~\ref{sec:servant_intro}, a delibirate choice has been made to let the Servant DSL live in the open kind \mintinline{haskell}{*}. Though this makes the DSL extensible, it also makes the DSL fragile and prone to error.

To give a real-world example, here is a snippet from a user on the Haskell Subreddit that could not get his API to work:

\begin{listing}[H]
\begin{minted}{haskell}
type SoundcloudTrackAPI = "tracks" :> 
  (    QueryParam "client_id" T.Text 
    :> QueryParams "genres" T.Text
    -> Get [JSON] [ST.Track] 
  :<|> QueryParam "client_id" T.Text
    :> Capture "id" Int
    :> Get [JSON] ST.Track
  )
\end{minted}
\caption{A malformed API}
\label{code:problem}
\end{listing}

The problem is hard to spot, but the user typed wrote \mintinline{haskell}{->} instead of \mintinline{haskell}{:>}.  This code compiles fine though. Because the Servant DSL lives in kind \mintinline{haskell}{*}, \mintinline{haskell}{:>} is   of kind \mintinline{haskell}{* -> * -> *}. Which is the same kind as the kind of \mintinline{haskell}{->}.

Only when one would try to interpret the DSL, like in Listing~\ref{code:interpret}, one would get a type error because no type family pattern matches on \mintinline{haskell}{->}.

\begin{listing}
\begin{minted}{haskell}
searchTracksByGenre :: Maybe T.Text 
                    -> [T.Text]
                    ->  Manager
                    -> BaseUrl
                    -> ClientM [ST.Track]
getTrack            :: Maybe T.Text
                    -> Int
                    -> Manager
                    -> BaseUrl
                    -> ClientM ST.Track
(searchTracksByGenre :<|> getTrack) = client soundcloudAPI 
\end{minted}
  \caption{An interpretation of the API (Listing ~\ref{code:problem})}
  \label{code:interpret}.
\end{listing}

Preferably, one would want to define a new open kind \mintinline{haskell}{API} such that \mintinline{haskell}{(:>) :: API -> API -> API}, but this is not possible in Haskell (or Idris). Instead, one could define a closed kind (using \textt{XDataKinds}), in which we define the entire Servant DSL. This would mean we would lose extensibility of the DSL, but we gain kind-safety.

Also, as described in Section~\ref{sec:servant_intro}, the Servant DSL is split up in several semantic portions.  For example, \mintinline{haskell}{:>} should take an \mintinline{haskell}{item} on the left-hand side, which describes either a constraint like \mintinline{haskell}{ReqBody} or a path-piece, whilst the right-hand side should be an \mintinline{haskell}{api}. These semantic portions are implict and not checked though. So we can create totally non-sensical API types like \mintinline{haskell}{type Nonsense = (Int :>Int) :<|> ("hey ":> Int)} that have no interpretation at all.

Instead of having these implicit semantic rules about what kind of arguments an operator can take in the Servant DSL, we could define a distinct closed kind for each semantic portion. Such that the type of \mintinline{haskell}{:>} changes to the following: \mintinline{haskell}{(:>) :: Item -> API -> API}.

Another implict rule is, that a chain of \mintinline{haskell}{:>} should always end in a \mintinline{haskell}{Get} or a \mintinline{haskell}{Post}. So this should be invalid: \mintinline{haskell}{type API = "a" :> ReqBody [JSON] User}.  This can also not be checked if we do not add more fine-grained kinds to the DSL.

\subsection{Explicit status codes}
An API that describes how stuff goes right is good, and API that describes how stuff goes wrong is great. But currently, Servant has no way to indicate in the API description what kind of status codes an endpoint can return. Thus this also does not show up in the generated documentation.

It would be nice to add a list of possible status codes that an endpoint can returns, and then also be able to check whether a server implementation actually only returns one of the specified status codes if something goes wrong (or right).

\subsection{Overlapping routes}
Another problem with Servant is that there is no protection for overlapping routes. If two routes could resolve to the same path, Servant makes a left-biased choice~\cite{servant}.
It would be nice if we could verify at compile time that no routes in an API specification can overlap.

\begin{listing}
\begin{minted}{haskell}
  type API  = "users" :> Capture "args" String :> Get [JSON] User
         :<|> "users" :> "favorites" :> GET [JSON] User
\end{minted}{haskell}
\caption{An example of overlapping routes. The capture will be chosen if args equals "favorites"}
\end{listing}



\section{Servis}
In this section, I present a DSL in Idris named Servis. It tries to address each issue listed in Section~\ref{sec:issues}. Firstly, we will define the DSL in which we can write API specifications. Then, we will look at how to write an interpreter of this DSL that generates documentation. Then, we will look at how we would implement HTTP webserver handlers that adhere to specification defined by the API DSL\@. Next, we'll look at solving the overlapping routes problem by writing proofs in Idris.
Finally, we will extend the DSL to add \emph{pi-types}, allowing us to describe dependencies in our API\@.  For example, one might want to describe  the size of a list of users in the API, but let the size depend on a query parameter \emph{limit} that limits the response size.  It would then force the implementor of the API to only return values smaller or equal to limit in size.

\subsection{The Universe pattern}
The Servis DSL makes use of the Universe pattern to map an API description to types of handlers.
 A universe is a type \mintinline{idris}{U : Type} which contains names for types and a type family \mintinline{idris}{el : U -> Type} that assigns to every name \mintinline{idris}{a : U} the type of its elements \mintinline{idris}{el a : Type} \cite{Altenkirch}\@.

 In idris, we could define this as the following interface:
 \begin{listing}
 \begin{minted}{idris}
interface Universe (u : Type) where
  el : u -> Type
 \end{minted}{idris}
   \caption{Universe interface in Idris}
 \end{listing}

 In our case, we have a datatype \mintinline{idris}{API : Type}, which describes our API, and \mintinline{idris}{el} maps values to handler types. A Short example:
 \begin{minted}{idris}

-- we define a value of API
api : API
api = Const "users" :> Capture Int "userId" :> Outputs (GET User)

getUser : Int -> IO User
getUser = ?someDatabaseMagic

--  el api evaluates to  Int -> IO User
handler : el api
handler = getUser
 \end{minted}
\subsection{The DSL}
So what does this type \mintinline{idris}{API} look like?
\subsubsection{Handler}\label{sec:handler}
Before we will look at routes, lets think of what an endpoint should look like.
We should be able to handle the HTTP verbs. We will only implement \mintinline{idris}{GET} and \mintinline{idris}{POST}, because the others are very similar.
For a \mintinline{idris}{GET}, we should be able to specify a return type of the handler,  and for a \mintinline{idris}{POST}, we should be able to
specify a request body type, and a return type.


A first try at describing this as a datatype for our universe  could look something like this:
\begin{listing}
  \begin{minted}{idris}
data Handler : Type where
  GET : (responseType : Type) -> Handler req res
  POST : (requestType : Type) -> (responseType : Type) -> Handler req res

Universe Handler where
  -- a GET handler just returns something of type responseType
  el (GET responseType) = IO responseType
  -- a POST handler takes the requestBody as argument, and returns a response
  el (POST requestType responseType) = requestType -> IO responseType

  \end{minted}
\end{listing}

We could then define a handler for \mintinline{idris}{GET}ting users as follows:
\begin{minted}{idris}
record User where
  constructor MkUser
  name : String
  email : String

userHandler : Handler
userHandler = GET User
\end{minted}

However, once we start implementating an actual server in Section~\ref{sec:server}, we will discover that this definition is not ideal. What if we want to write some
function that does something different based on the \mintinline{idris}{responseType} of a \mintinline{idris}{GET}?
For example, based on value of \mintinline{idris}{responseType}, we need to decide how to encode the response body to JSON. Lets imagine a hypothetical function \mintinline{idris}{selectEncoder} that tries to implement this behaviour:

\begin{minted}{idris}
selectEncoder : Type -> Encoder
selectEncoder User = ?jsonEncoderForAUser

userEncoder : Encoder
userEncoder = selectEncoder User
\end{minted}{idris}

Sadly enough, this will give us a compiler error. The problem is that in Idirs, we cannot pattern match on values of \mintinline{idris}{Type}. 
However, this exact problem can be solved with universes! We can define a data type \mintinline{idris}{ResponseUniverse : Type} which names
the \mintinline{idris}{User} type. We can then pattern-match on \mintinline{idris}{ResponseUniverse} instead of \mintinline{idris}{Type}!
And whenever we need the \mintinline{idris}{User} type, we can just call \mintinline{idris}{el USER : Type}.

\begin{minted}{idris}
data ResponseUniverse : Type where
  USER : ResponseUniverse

Universe ResponseUniverse where
  el USER = User

selectEncoder : ResponseUniverse -> Encoder
selectEncoder USER = ?jsonEncoderForAUser

userEncoder : Encoder
userEncoder : selectEncoder USER
\end{minted}

This leads us to the following definition of \mintinline{idris}{Handler}:

\begin{listing}
  \begin{minted}{idris}
data Handler : (req : Type)  -> (res : Type) -> Type where
  GET : (responseType : res) -> Handler req res
  POST : (requestType : req) -> (responseType : res) -> Handler req res

(Universe req, Universe res) => Universe (Handler req res) where
  el (GET responseType) = IO (el responseType)
  el (POST requestType responseType) =
    el requestType -> IO (el responseType)
  \end{minted}
  \caption{The new Handler definition}
\end{listing}

\subsubsection{Path and PathPart}
Of course we do not only get request information from the request body,
we also get information about a request by parsing it's request URL. This
is where \mintinline{idris}{Path}s and \mintinline{idris}{PathPart}s come into play. 
When we talk about path parts, we mean sections of an path template that convey parsable information.
For example, the following path template has three path parts: \texttt{/users/\string{user\_id\string}?search=\string{query\string}}. A constant piece
in the path \texttt{users}, a variable capture \texttt{user\_id} and a query param \texttt{search}. This
decomposition of a path template can be written down as a datatype. In this datatype we do not only
want to describe the names of the parts of these paths, but also their types. Hence, we will parameterize
over a universe similarly to how we defined \mintinline{idris}{Handler}.
\begin{minted}{idris}

||| PathPart is a part of a path.
||| @ capture the universe of captures
||| @ query   the universe of query params
data PathPart : (capture : Type) -> (query : Type) -> Type where
  ||| A constant piece of text
  ||| @ path the path part
  Const : (path : String) -> PathPart capture query
  ||| A capture of a variable name of a specific type
  ||| @ name  the name of the variable
  ||| @ type  the type of the variable
  Capture : (name : String) -> (type : capture) -> PathPart capture query
  ||| A query param of a variable name of a specific type
  ||| @ name  the name of the variable
  ||| @ type  the type of the variable
  QueryParam : (name : String) -> (type : query) -> PathPart capture query
\end{minted}

A \mintinline{idris}{Path} is simply a list if \mintinline{idris}{PathPart}s, which ends in a \mintinline{idris}{Handler}:
\begin{minted}{idris}
||| Describes a Path. A Path consists of path parts followed by a handler
data Path : (capture : Type) -> 
            (query : Type) ->
            (req : Type) ->
            (res : Type) -> Type where
  ||| Ends a path with a handler
  ||| @ handler the handler
  Outputs : (handler : Handler req res) -> Path capture query req res
  ||| Conses a pathpart to a path
  (:>) : PathPart capture query ->
         Path capture query req res ->
         Path capture query req res
infixr 5 :>
\end{minted}

The Path we just described can now be written as
\begin{minted}{idris}
   Const "users"
:> Capture "user_id" INT
:> QueryParam "search" STRING
:> Outputs (GET USER)
\end{minted}

The universe implementation is straightforward for paths, except for
that we do not wannt to have spurious arguments in case when we encounter
a \mintinline{idris}{Const}:
\begin{minted}{idris}
( Universe capture
, Universe query
) => Universe (PathPart capture query) where
  el (Const path) = ()
  el (Capture name type) = el type
  el (QueryParam name type) = el type


( Universe capture
, Universe query
, Universe req
, Universe resp
) => Universe (Path capture query req resp) where
  -- special case because we don't like () in our handler functions
  el (Const path :> right) =  el right
  el (pathPart :> right) = el pathPart -> el right
  el (Outputs handler) = el handler
\end{minted}

\subsubsection{The API Datatype}
Finally, we define an \mintinline{idris}{API} as an non-empty list of \mintinline{idris}{Path}s.

\begin{minted}{idris}
data API : (capture : Type) -> (query : Type) -> (req : Type) -> (res : Type) -> Type where
  OneOf : (paths : Vect (S n) (Path capture query req res)) -> API capture query req res
\end{minted}

The universe implementation of an \mintinline{idris}{API} is the type of a list of handlers.
Every handler is of a different type though, so instead of using an ordinary list,
we use an heterogenous list, where each element \mintinline{idris}{x} in \mintinline{idris}{xs}
is of type \mintinline{idris}{el x}.
\begin{minted}
( Universe capture
, Universe query
, Universe req
, Universe res
) => Universe (API capture query req res) where
  el (OneOf xs) = HVect (map el xs)
\end{minted}.

\subsection{An example API}
Using this DSL, we will now describe an API for interacting with users in a database.
We will start of with defining our domain objects, and intercations we could do with them.

\begin{listing}
\begin{minted}{idris}
record User where
  constructor MkUser
  id : Int
  name : String
  email : String
  password : String


findUserByName : String -> IO (List User)
getUsers : (limit : Int) -> IO (List User)
getUserById : (id : Int) -> IO User
addUser : User -> IO ()
\end{minted}
\label{domain}
\caption{The User object and its interactions}
\end{listing}

Next, we will describe the HTTP API for interacting with these users.  This includes
the need of coming up with universes for captures, query params, request body, and response.

\begin{listing}
\begin{minted}{idris}
data QueryUniverse
  = QSTRING
  | QINT
Universe QueryUniverse where
  el QSTRING = String
  el QINT = Int

data CaptureUniverse
  = CINT
Universe CaptureUniverse where
  el CINT = Int

-- Note: We use the same universe for requests and responses.
data ReqResUniverse
  = USER
  | LIST ReqResUniverse
Universe ReqResUniverse where
  el USER = User
  el (LIST a) = List (el a)

userAPI : API QueryUniverse CaptureUniverse ReqResUniverse ReqResUniverse
userAPI = OneOf
  [ Const "users" :> Capture "user_id" CINT :> Outputs (GET USER)
  , Const "users" :>
    Const "find" :>
    QueryParam "email" QSTRING :>
    Outputs (GET (LIST USER))
  , Const "users" :> Outputs (POST USER)
  , Const "users" :>
    QueryParam "limit" QINT :>
    Outputs (GET (LIST USER))
  ]
\end{minted}
\label{code:api}
\caption{API definition for users}
\end{listing}

\subsection{A simple interpreter: Documentation generation}
Writing an interpreter for generating documentation is very easy. Our API description isn't some type-level definition, it's just a plain old datatype that can be passed to functions and can be manipulated.

We start by introducing an interface for docs:
\begin{minted}{idris}
interface HasDocs a where
  docs :: a -> String
\end{minted}
Now, we just define an implementation for \mintinline{idris}{API} for this interface and we're done. Which is just calling \mintinline{idris}{docs} recursively on all its children.

\begin{minted}{idris}
(HasDocs req, HasDocs res) => HasDocs (Handler req res) where
  docs (GET responseType) =
    "## GET\nResponse type: " ++ docs responseType

  docs (POST requestType responseType) =
    "## POST\nRequest type: "  ++ docs requestType ++ "\n" ++
    "Response type: " ++ docs responseType ++ "\n"

renderParams : HasDocs query => List (String, query) -> String
renderParams = renderParams' . reverse
  where
    renderParams' : List (String, query) -> String
    renderParams' [] = ""
    renderParams' ((a, b) :: []) =
      "?" ++ a ++ "=<"++ docs b ++ ">"
    renderParams' ((a, b) :: xs) =
      renderParams' xs ++ "&" ++ a ++ "=<"++ docs b ++ ">"

renderPath : 
  ( HasDocs capture
  , HasDocs query
  , HasDocs req
  , HasDocs resp) => Path capture query req resp -> String -> String
renderPath (Outputs x) params = 
    params ++ "\n" ++ docs x
renderPath ((Const x) :> y) params =
    "/" ++ x ++ renderPath y params
renderPath ((Capture name type) :> y) params =
  "/<" ++ name ++ ":" ++ docs type ++ ">" ++ renderPath y params
renderPath _ _ = ""

( HasDocs capture
, HasDocs query
, HasDocs req
, HasDocs resp
) => HasDocs (Path capture query req resp) where
  docs path =
    "# " ++ renderPath path (renderParams . getParams $ path) ++ "\n"
    where

      getParams : Path capture query req resp -> List (String, query)
      getParams (Outputs x) = []
      getParams ((Const x) :> y) = getParams y
      getParams ((Capture name type) :> y) = getParams y
      getParams ((QueryParam name type) :> y) = (name, type) :: getParams y


( HasDocs capture
, HasDocs query
, HasDocs req
, HasDocs resp
) => HasDocs (API capture query req resp) where
  docs (OneOf (x::[])) = docs x
  docs (OneOf (x::y::xs)) = docs x ++ "\n" ++ oneOf (y::xs)
\end{minted}

Now \mintinline{idris}{docs userAPI}, assuming that the universes implement
the \mintinline{idris}{HasDocs} interface, will evaluate to a very basic form of documentation:
\begin{verbatim}
# /users/<user_id:CINT>
## GET
 Response type: USER
# /users/find?email=<QSTRING>
## GET
 Response type: LIST USER

# /users?limit=<QINT>
## GET
 Response type: LIST USER

# /users
## POST
Request type: USER
Response type: USER

# /users?limit=<QINT>
## GET
 Response type LIST USER
\end{verbatim}

\subsection{An interpreter for an HTTP Server}\label{sec:server}
Now that we've shown that it is easy to manipulate APIs because they're just datatypes, it's time for a more complicated example. Though it is cool that we can generate documentation from an API description, the useful part that we want to implement is an HTTP Server.

\subsubsection{A type for web applications}
Lets first ask the question how a web server should look like in Idris. In the Servant paper, they describe the type of http handlers in the \texttt{wai} library, which looks like \cite{servant}:
\begin{minted}{haskell}
type Application = Request -> IO Response
\end{minted}.

We will more-or-less use this representation to model our HTTP handlers. they are  simply a function from request to response.  The actual implementation of a web server based on this model is out of scope for now, but it would be interesting to port something like Haskells' \texttt{warp} (which impelements this concept) to Idris.

Instead of having two abstract types \mintinline{idris}{Request} and \mintinline{idris}{Response}, we will assume for simplicity that a \mintinline{idris}{Response} is just a \mintinline{idris}{String}, and that a \mintinline{idris}{Request} is an \mintinline{idris}{URL}, and a requestBody of type \mintinline{idris}{Maybe String}.

\begin{minted}{idris}
Application : Type
Application = (url : URL) -> (requestBody : Maybe String) -> IO String
\end{minted}

Just like in the Servant paper, we will need to modify this type a little bit more to suit our needs. We need to be able to express that an \mintinline{idris}{Application} does not match in case of a routing mismatch, such that we can try another route encompassed in \mintinline{idris}{OneOf}. 

Instead of returning  a value of \mintinline{idris}{IO String}, we can return a value of \mintinline{idris}{Maybe (IO String)}, where \mintinline{idris}{Just} signals a route match, whilst \mintinline{idris}{Nothing} signals a route mistmatch such that we can try another route.

\begin{minted}{idris}
RoutingApplication : Type
RoutingApplication = (url : URL) ->
                     (requestBody : Maybe String)
                     -> Maybe (IO String)
\end{minted}

\subsubsection{Decoding and encoding data}
In section~\ref{sec:handler}, we showed that if we want to implement some decoder, we would have to resort
to the universe pattern. So that is what we will do exactly here.

As an example, we will show how we would decode a queryparam. All other decoders follow the same pattern.
What we want to do is, given a \mintinline{idris}{queryParam : String}, and a value \mintinline{idris}{v : u},
where \mintinline{idris}{u} is the universe of query param types, and  \mintinline{idris}{v} a name of a type in that universe,
perform the correct decoding to get a value of type \mintinline{idris}{el v}.

We can summarize this behaviour in an interface:
\begin{minted}{idris}
interface Universe u => FromQueryParam u where
  fromQueryParam : (v : u) -> String -> Maybe (el v)
\end{minted}

similarly, we have interfaces for captures and request bodies:
\begin{minted}{idris}
interface Universe u => FromCapture u where
  fromCapture : (v : u) -> String -> Maybe (el v)

interface Universe u => FromRequest u where
  fromRequest : (v : u) -> String -> Maybe (el v)
\end{minted}

An implementation of \mintinline{idris}{FromQueryParam} for the universe \mintinline{QueryUniverse} in Listing~\ref{code:api}, would look like this:

\begin{minted}{idris}
FromQueryParam QueryU where
  fromQueryParam QINT str = maybeParseInt str
\end{minted}

The fact that we can pattern match on the universe lets us inspect what type we need to return,
and select the right decoder accordingly.

We can use the same technique for encoding responses:
\begin{minted}{idris}
interface Universe u => ToResponse u where
  toResponse : (v : u) -> el v -> String

\end{minted}

For example, we could use this to encode values in the \mintinline{idris}{ReqResUniverse} universe from
Listing~\ref{code:api}:
\begin{minted}{idris}
  ToResponse ReqResUniverse where
    toResponse USER (MkUser id name email password) =
      "MkUser " ++ show id ++ " " ++ show name
    toResponse (LIST elem) xs =
      foldr (++) ""  . map (toResponse elem) $ xs
\end{minted}

\subsubsection{Routing requests}
We will define the following interface to implement routing requests:
\begin{minted}{haskell}
interface Universe u => HasServer u where
  route : (v : u) -> (handler : el v) -> RoutingApplication
\end{minted}
Or if we expaned the definition \mintinline{idris}{RoutingApplication}:
\begin{minted}{haskell}
interface Universe u => HasServer u where
  route : (v : u) ->
          (handler : el v) ->
          (url : URL) ->
          (requestBody : Maybe String)
          -> Maybe (IO String)
\end{minted}

The idea of the router is, that given some part of the API \mintinline{idris}{v : u}, and a handler of type \mintinline{idris}{el v}, build an application that can either route succesfully or fail. Preferably, the application uses the handler parameter in its implementation of course.

Lets start by defining an \mintinline{idris}{HasServer} instance for \mintinline{idris}{Handler}. Its task is to simply encode responses to Strings, and to handle request bodies to calculate responses
by calling the handler and encoding its result.
\begin{minted}{idris}
(FromRequest req, ToResponse res) => HasServer (Handler req res) where
  -- route : Handler req res -> 
  --         (handler : IO res) ->
  --         URL -> Maybe String -> Maybe (IO String)
  ||| simply turn an (IO res) into an (IO String) 
  ||| using toResponse
  route (GET responseType) handler url requestBody =
    Just (map (toResponse responseType) handler)
  route (POST requestType responseType) handler url requestBody = do
    -- see if there is a requestBody. otherwise fail
    body <- requestBody
    -- try to decode the request. this might fail and return Nothing
    request <- fromRequest requestType body
    -- apply the decoded request to the handler, and encode the result
    Just (map (toResponse responseType) (handler request))
\end{minted}

\subsection{A proof of non-overlapping routes}
We will describe types for helping prove that routes in an API definition don't overlap.  We do this
by providing Decidable Equality proofs for all parts of our DSL.
\begin{minted}{idris}

\end{minted}
\subsection{Pi-types}
Adds dependent pairs to our DSL such that we can describe dependencies between query params, captures and return types.  Example:

\begin{minted}{haskell}
exampleOfDependentPath : Path EmptyU QueryU EmptyU RespU
exampleOfDependentPath =
  QueryParam "limit" NAT :*> \limit => Outputs (GET (BLIST limit USER))

getUsersLimit : (limit : Nat) -> IO (BoundedList limit User)
getUsersLimit limit = pure . take limit $ users

exampleOfDependentPathHandler : el Example.exampleOfDependentPath
exampleOfDependentPathHandler = getUsersLimit

\end{minted}
\subsection{New problems that pi-type create}
Here we will describe how pi-types adds problems. For example we cannot easily generate documentation anymore, prove that there are no overlapping routes, or prove that statuscodes are adhered to.

\section{Summary}
\section{Related work}
Talk about tel/serv. An inspiration for this project.
\section{Conclusions and future work}

\bibliography{sources}
\bibliographystyle{plain}
\end{document}
